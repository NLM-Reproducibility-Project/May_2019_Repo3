---
title: 'Junction reads'
author: "Manfred Schmid"
output: html_document
---

`r format(Sys.time(), "%d %B, %Y")`

```{r}
knitr::opts_chunk$set(fig.width=12, fig.height=8, 
                      fig.path=paste0('Figures_junction_reads/'), 
                      dev='pdf', echo=TRUE, warning=FALSE, message=FALSE, 
                      error=TRUE)
```


```{r load packages, echo=T, warning=F, message=F}
suppressWarnings(library(tidyverse))
suppressWarnings(library(magrittr))
suppressWarnings(library(knitr))
```


## Collect Junction Reads

using python script *count_junctions.py*
```{python, eval = FALSE}
#!/usr/bin/env python
'''

Counts reads for each exon-exon, exon-intron and intron-exon junctions for all introns in a BED file

Usage: count_junctions.py bamfile introns_bedfile [--min_overlap, --expand_size, --reportOverlapLength]

For this way of counting its easiest to provide a bed file for the introns.
The bam file needs to be sorted and have an index file. The bed file does not need to be sorted

writes simply the 6-column bed file adding columns EE_count, SD_count, SA_count, intronic, ambigous counts as additional columns

where
. SD is splice-donor ie 5'SS (EI on plus strand and IE on minus strand)

. SA is splice-acceptor ie 3'SS (IE on plus strand and EI on minus strand).

if --reportOverlapLength is TRUE:
adds additional columns consisting of comma-separated lists for length of EE_up EE_dn SD_up SD_dn SA_up SA_dn overlaps
'''

__author__ = 'schmidm'

import sys
import argparse
import HTSeq


parser = argparse.ArgumentParser(usage=__doc__)
parser.add_argument('bam_file')
parser.add_argument('bed_file')
parser.add_argument('--min_overlap', default=2, type=int, help="minimum base pair overlap required upstream and downstream of junction")
parser.add_argument('--expand_size', default=100, type=int, help="expand intron by this size on each size in first pass filtering of reads and only consider those reads for classification")
parser.add_argument('--reportOverlapLength', default=False, action="store_true", help="report length of upstream and downstream overlaps for each overlap type")
args = parser.parse_args()


bam_file = sys.argv[1]
bed_file = sys.argv[2]

MIN_OVERLAP = args.min_overlap #minimum amount of bases on each side of a junction that need to be present for a call
WINDOW_SIZE = args.expand_size # only consider reads with start or end within intron +/- WINDOW_SIZE usually read-length


class INTERVAL:

    def __init__(self, line):
        self.chr = line[0]
        self.start = int(line[1])
        self.end = int(line[2])
        self.id = line[3]
        self.score = line[4]
        self.strand = line[5]
        self.EE = [] #exon-exon splice junction reads
        self.SA = [] #splice acceptor ie 5'SS exon-intron junction reads
        self.SD = [] #splice donor ie 5'SS exon-intron junction reads
        self.ambigous = 0
        self.intronic = 0

    def add_read(self, iv):
        if iv.start < self.end:
            # upstream or overlapping
            if (self.start - WINDOW_SIZE) < iv.start < (self.start - MIN_OVERLAP) and iv.end > self.start:
                # alignment starts upstream and ends internal or downstream
                if (self.start + MIN_OVERLAP) < iv.end < self.end:
                    self.add_EI(iv)
                elif (self.end + MIN_OVERLAP) < iv.end < (self.end + WINDOW_SIZE) :
                    self_found = False
                    # make sure there is no internal alignment to intron
                    for cigop in aligned_read.cigar:
                        if cigop.type == "M" and self.overlaps_internal(cigop.ref_iv):
                            self_found = True
                            break
                    if not self_found:
                        self.add_EE(iv)
                    else:
                        self.ambigous += 1
                else:
                    self.ambigous += 1

            elif self.start < iv.start < (self.end - MIN_OVERLAP):
                # alignment starts inside
                if iv.end < self.end:
                    # alignments ends internal --> intronic
                    self.intronic += 1
                elif (self.end + MIN_OVERLAP) < iv.end < (self.end + WINDOW_SIZE) :
                    self.add_IE(iv)
                else:
                    self.ambigous += 1


    def add_EE(self, iv):
        self.EE.append(iv)
        #self.EE += 1
        #self.EEdists.append((self.start - iv.start, iv.end - self.end))

    def add_IE(self, iv):
        if self.strand == '+':
            self.SA.append(iv)
            #self.SA += 1
            #self.SAdists.append((self.end - iv.start, iv.end - self.end))
        else:
            self.SD.append(iv)
            #self.SD += 1
            #self.SDdists.append((self.start - iv.start, iv.end - self.start))

    def add_EI(self, iv):
        if self.strand == '+':
            self.SD.append(iv)
            #self.SA += 1
            #self.SAdists.append((self.end - iv.start, iv.end - self.end))
        else:
            self.SA.append(iv)
            #self.SD += 1
            #self.SDdists.append((self.start - iv.start, iv.end - self.start))

    def overlaps_internal(self, iv):
        ''' checks whether interval has any overlap with the bedinterval,
            ie whether there are intronic parts in the interval '''
        if iv.start < self.start and iv.end > self.start:
            return True
        elif iv.start < self.end and iv.end > self.end:
            return True
        elif iv.start > self.start and iv.end < self.end:
            return True
        return False

    def summary_str(self):
        '''
        :return: summary of object, ie counts per junction as string
        '''
        return '\t'.join([self.chr, str(self.start), str(self.end), self.id, self.score, self.strand, str(len(self.EE)), str(len(self.SD)), str(len(self.SA)), str(self.intronic), str(self.ambigous)])

    def overlaps_as_str(self):
        '''
        :return: tab separate list of comma-separated lists for upstream and downstream overlaps for EE, SD, SA
        '''

        if self.strand == '+':
            ee_up = ','.join(str(self.start - ee.start) for ee in self.EE)
            ee_dn = ','.join(str(ee.end - self.end) for ee in self.EE)
            sd_up = ','.join(str(self.start - ee.start) for ee in self.SD)
            sd_dn = ','.join(str(ee.end - self.start) for ee in self.SD)
            sa_up = ','.join(str(self.end - ee.start) for ee in self.SA)
            sa_dn = ','.join(str(ee.end - self.end) for ee in self.SA)

        else:
            sa_dn = ','.join(str(self.start - ee.start) for ee in self.SA)
            sa_up = ','.join(str(ee.end - self.start) for ee in self.SA)
            sd_dn = ','.join(str(self.end - ee.start)  for ee in self.SD)
            sd_up = ','.join(str(ee.end - self.end) for ee in self.SD)
            ee_dn = ','.join(str(self.start - ee.start)  for ee in self.EE)
            ee_up = ','.join(str(ee.end - self.end) for ee in self.EE)

        return ee_up + '\t' + ee_dn + '\t' + sd_up + '\t' + sd_dn + '\t' + sa_up + '\t' + sa_dn


##parse the bed file
bed_lines = [ INTERVAL(line.rstrip().split( "\t" )) for line in open( bed_file ) ]

##load the bam file
almnt_file = HTSeq.BAM_Reader( bam_file )

unaligned_count = 0
outside_range_count = 0
i = 0

if not args.reportOverlapLength:
    print 'chr', '\t', 'start', '\t', 'end', '\t', 'id', '\t', 'score', '\t', 'strand', '\t', 'EE', '\t', 'SD', '\t', 'SA', '\t', 'intronic', '\t','ambigous'
else:
    print 'chr', '\t', 'start', '\t', 'end', '\t', 'id', '\t', 'score', '\t', 'strand', '\t', 'EE', '\t', 'SD', '\t', 'SA', '\t', 'intronic', '\t', 'ambigous', '\t', 'EE_up', '\t', 'EE_dn',' \t', 'SD_up', '\t', 'SD_dn', '\t', 'SA_up', '\t', 'SA_dn'

for intron in bed_lines:
    if intron.strand == '+':
        read_strand = '-'
    else:
        read_strand = '+'
    intron_window = HTSeq.GenomicInterval( intron.chr, intron.start - WINDOW_SIZE, intron.end + WINDOW_SIZE, read_strand )

    for aligned_read in almnt_file[intron_window]:
        if not aligned_read.aligned:
            unaligned_count += 1
            continue
        iv = aligned_read.iv

        if not aligned_read.optional_field('NH') == 1:
            continue

        if not iv.strand == read_strand:
            #not: almnt_file[intron_window] ignores the strand info even though its there
            continue

        intron.add_read(iv)

    if not args.reportOverlapLength:
        print intron.summary_str()
    else:
        print intron.summary_str() + '\t' + intron.overlaps_as_str()
```

called from remote via bash script using settings:
```{bash, eval = FALSE}
#!/usr/bin/env bash

bam="/Volumes/GenomeDK/faststorage/Lexogen2/STAR_map/42448_AATAGC_C9P6RANXX_5_20160808B_20160808_trimmed_cleanAligned.sortedByCoord.out.bam"
bed="/Users/schmidm/Documents/genomewide_datasets/annotations/sacCer3/sacCer3_ORFT_introns.bed"

for bam in /Volumes/GenomeDK/faststorage/Lexogen2/STAR_map/*_trimmed_cleanAligned.sortedByCoord.out.bam
do
  echo $bam
  python ~/ms_tools/MS_Metagene_Tools/count_junctions.py $bam $bed --expand_size 50 --reportOverlapLength > ${bam/.bam/junctions.countsv2}
done
```

--> copy to local folder  


at the time this was run we had HTSeq version *0.7.2* as evaulated by
```{python, eval = FALSE}
#!/usr/bin/env python

import HTSeq

print HTSeq.__version__
```



## Load the junction reads in R


#### load bam file name map

```{r}
(bam_files <- read.table('/Users/schmidm/Documents/Results/Lexogen_RNAseq_2/file_rename_map_Lexogen2.txt',
           col.names = c('simple_name', 'bam_name')) %>%
  tbl_df)

bam_file_map <- bam_files$simple_name
names(bam_file_map) <- bam_files$bam_name
```


#### load counts
```{r}
path <- '/Users/schmidm/Documents/Results/Lexogen_RNAseq_2/splicing_stuff/junctions/'

sfx <- 'junctions.countsv2'

files <- dir(path) %>% keep(grepl(sfx, .))

file <- files[1]
(d <- lapply(files, function(file) {read.table(paste0(path,file), 
                                              header=T, sep='\t', stringsAsFactors = FALSE) %>%
                                   mutate(condition = bam_file_map[sub(sfx, '', file)]) %>%
                                   tbl_df}) %>%
  bind_rows)
```

```{r}
(dlong <- d %>%
  mutate(SDplusSA = SD + SA) %>%
  select(id, EE, SDplusSA, condition) %>%
  gather(read_type, count, -id, -condition) %>%
  separate(condition, c('Pap', 'strain', 'fraction', 'rapa', 'rep'), sep='_'))
```

```{r barplot junction counts sum}
dlong %>%
  group_by(Pap, strain, fraction, rapa, rep, read_type) %>%
  summarize(count = sum(count)) %>%
  ggplot(., aes(x=rep, y=count, fill=read_type)) +
  geom_bar(stat='identity', position='dodge') +
  scale_fill_brewer(palette = 'Set1') +
  facet_grid(rapa~Pap+strain+fraction) +
  theme_bw() +
  theme(axis.text.x=element_text(hjust=1, angle=45))
```


#### normalize to S.pombe

```{r}
(sf <- read.table('data/Sp_genes_sf.txt', col.names=c('condition', 'sf')) %>%
  separate(condition, c('Pap', 'strain', 'fraction', 'rapa', 'rep'), sep='_') %>%
  tbl_df)
```


```{r barplot junction counts sum normalized to Spombe}
dlong %>%
  group_by(Pap, strain, fraction, rapa, rep, read_type) %>%
  summarize(count = sum(count)) %>%
  left_join(., sf) %>%
  mutate(norm_count = count/sf) %>%
  ggplot(., aes(x=rep, y=norm_count, fill=read_type)) +
  geom_bar(stat='identity', position='dodge') +
  scale_fill_brewer(palette = 'Set1') +
  facet_grid(rapa~Pap+strain+fraction) +
  theme_bw() +
  theme(axis.text.x=element_text(hjust=1, angle=45))
```



## Distance to junction
```{r}
overlap_size_table <- function(d, colname) {
  tab <- d[[colname]] %>% 
  keep(. != '') %>% 
  strsplit(., split=',') %>% 
  unlist %>% 
  as.numeric %>% 
  table %>%
    data.frame
  
  colnames(tab) <- c('distance', 'count')
  tab
}
```

```{r}
(overlaps <- d %>%
  group_by(condition) %>%
  do(ee_up = overlap_size_table(., 'EE_up'),
     ee_dn = overlap_size_table(., 'EE_dn'),
     sd_up = overlap_size_table(., 'SD_up'),
     sd_dn = overlap_size_table(., 'SD_dn'),
     sa_up = overlap_size_table(., 'SA_up'),
     sa_dn = overlap_size_table(., 'SA_dn')) %>%
  gather(junction_type, df, -condition) %>%
  unnest(.) %>%
  separate(condition, c('Pap', 'strain', 'fraction', 'rapa', 'rep'), sep='_'))
```


```{r}
ggplot(overlaps, aes(x=as.numeric(distance), y=count, color=junction_type)) +
  geom_point() +
  stat_smooth() +
  facet_wrap(rapa~Pap+strain+fraction) +
  xlim(0,50)
```


```{r}
filter(overlaps, Pap == 'xPap', rapa == 0, fraction == 'ip') %>%
  ggplot(., aes(x=as.numeric(distance), y=count, color=rep)) +
  geom_point() +
  stat_smooth(aes(x=as.numeric(distance), y=count), inherit.aes = FALSE) +
  facet_grid(rapa+junction_type~Pap+strain+fraction, scales='free') +
  xlim(0,50)
```

what is visible?  
mostly effects for downstream distance:  
   * EE vs SD vs SA seem to behave quite differently.
   * EE_dn generally weakly depleted close to junction (ie splicing takes time?)
   * SA_dn increased close to junction ... ie stalling?
   * SD_dn major spike 5bp downstream of junction ... pausing or decay intermediates??


for upstream distance effects are mostly for more distal positions, meaning unclear, for SD and EE there will be some bias since we generally observe less signal close to 5' ends and exon 1's are short. For the SA upstream overlap size this is essentially covering the intron and perhaps biased by speed of polymerase although its not terribly clear.  

```{r}
filter(overlaps, Pap == 'xPap', rapa == 0, fraction == 'input') %>%
  ggplot(., aes(x=as.numeric(distance), y=count, color=rep)) +
  geom_point() +
  stat_smooth(aes(x=as.numeric(distance), y=count), inherit.aes = FALSE) +
  facet_grid(rapa+junction_type~Pap+strain+fraction, scales='free') +
  xlim(0,50)
```

counts are extremely low for the EE junctions. Therefore, none of these is terribly convincing ... leave for now without further conclusion.  


```{r}
sessionInfo()
```
